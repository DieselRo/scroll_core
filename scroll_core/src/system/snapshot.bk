// ===============================
// src/system/snapshot.rs
// ===============================

use std::fs::{self, File};
use std::io::{Write, BufWriter};
use std::path::{Path, PathBuf};
use chrono::Local;

/// Recursively gather all .rs source files under /src and append them to a reference .md file.
/// Output is saved to /scrolls/docs/source_index_YYYY-MM-DD_HHMM.md
pub fn generate_source_index(root_dir: &str, output_dir: &str) -> std::io::Result<()> {
    let mut source_files = Vec::new();
    let src_path = Path::new(root_dir).join("src");

    gather_rs_files(&src_path, &mut source_files);

    let now = Local::now();
    let timestamp = now.format("%Y-%m-%d_%H%M");
    let output_filename = format!("source_index_{}.md", timestamp);
    let output_path = Path::new(output_dir).join(output_filename);

    let file = File::create(&output_path)?;
    let mut writer = BufWriter::new(file);

    writeln!(writer, "# ðŸ“¦ scroll_core â€“ Source Reference Snapshot ({})\n", timestamp)?;

    for file_path in source_files {
        writeln!(writer, "---\n\n## ðŸ“„ File: {}\n", file_path.display())?;
        writeln!(writer, "```rust")?;

        if let Ok(content) = fs::read_to_string(&file_path) {
            writer.write_all(content.as_bytes())?;
        } else {
            writeln!(writer, "// Failed to read file contents.")?;
        }

        writeln!(writer, "```\n")?;
    }

    writeln!(writer, "---\n\nðŸŒ€ Generated by Scroll Core CLI â€“ Reference Snapshot")?;
    Ok(())
}

fn gather_rs_files(dir: &Path, files: &mut Vec<PathBuf>) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                gather_rs_files(&path, files);
            } else if path.extension().map_or(false, |ext| ext == "rs") {
                files.push(path);
            }
        }
    }
}
