// src/system/snapshot.rs
// ==============================

use chrono::Local;
use std::fs::{self, File};
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};

/// Recursively gather all .rs source files under a given src directory.
fn gather_rs_files(dir: &Path, files: &mut Vec<PathBuf>) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                gather_rs_files(&path, files);
            } else if path.extension().map_or(false, |e| e == "rs") {
                files.push(path);
            }
        }
    }
}

/// Generate a single Markdown snapshot file containing:
///   - workspace‚Äëroot Cargo.toml
///   - each member‚Äôs Cargo.toml
///   - all their src/**/*.rs files
pub fn generate_source_index(root_dir: &str, output_dir: &str) -> std::io::Result<()> {
    let workspace = Path::new(root_dir);
    let mut items = Vec::new();

    // 1) Snapshot the workspace Cargo.toml
    items.push(workspace.join("Cargo.toml"));

    // 2) For each workspace member, snapshot manifest + src/
    for member in &["scroll_core", "migration"] {
        let member_root = workspace.join(member);
        // member's Cargo.toml
        items.push(member_root.join("Cargo.toml"));
        // all *.rs under member/src
        let src_dir = member_root.join("src");
        gather_rs_files(&src_dir, &mut items);
    }

    // prepare output file
    let now = Local::now();
    let ts = now.format("%Y-%m-%d_%H%M");
    let filename = format!("source_index_{}.md", ts);
    let outpath = Path::new(output_dir).join(&filename);
    let file = File::create(&outpath)?;
    let mut w = BufWriter::new(file);

    // header
    writeln!(w, "# üì¶ scroll_core ‚Äì Source Reference Snapshot ({})\n", ts)?;

    // dump each item in order
    for path in items {
        let rel = path.strip_prefix(workspace).unwrap_or(&path).display();
        // choose fence by extension
        let (fence, lang) = match path.extension().and_then(|e| e.to_str()) {
            Some("toml") => ("```toml", "toml"),
            Some("rs") => ("```rust", "rust"),
            _ => ("```", ""),
        };
        writeln!(w, "---\n\n## üìÑ File: {}\n", rel)?;
        writeln!(w, "{}", fence)?;

        match fs::read_to_string(&path) {
            Ok(text) => w.write_all(text.as_bytes())?,
            Err(_) => writeln!(w, "// ‚ö†Ô∏è Failed to read {}", rel)?,
        }

        writeln!(w, "```\n")?;
    }

    writeln!(
        w,
        "---\n\nüåÄ Generated by Scroll Core CLI ‚Äì Reference Snapshot"
    )?;
    Ok(())
}
